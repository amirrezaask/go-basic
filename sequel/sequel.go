package sequel

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"fmt"
	"os"
	"reflect"
	"regexp"
	"runtime"
	"strings"
	"testing"
	"time"

	"github.com/amirrezaask/go-std/dump"
	"github.com/amirrezaask/go-std/errors"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

type metrics struct {
	QueryHV *prometheus.HistogramVec
	ExecHV  *prometheus.HistogramVec
}

type Interface interface {
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	ExecContext(ctx context.Context, stmt string, args ...any) (sql.Result, error)
	Query(query string, args ...any) (*sql.Rows, error)
	Exec(stmt string, args ...any) (sql.Result, error)
	BeginTx(ctx context.Context, options *sql.TxOptions) (*sql.Tx, error)
	Begin() (*sql.Tx, error)
	Driver() driver.Driver
}

const (
	sqlite = "sqlite3"
	mysql  = "mysql"
)

func getDriver(s Interface) string {
	switch fmt.Sprintf("%T", s.Driver()) {
	case "*sqlite3.SQLiteDriver":
		return sqlite
	case "*mysql.MySQLDriver":
		return mysql
	default:
		return "unknown"
	}
}

type database struct {
	Interface
	DbName  string
	metrics *metrics
	debug   bool
}

type ConnectionOptions struct {
	PromNS                string
	MaxOpenConnections    int
	MaxIdleConnections    int
	IdleConnectionTimeout time.Duration
	OpenConnectionTimeout time.Duration
}

func isDebug(s Interface) bool {
	if our, isOurSql := s.(*database); isOurSql {

		return our.debug || os.Getenv("SEQUEL_DBG") == "true"
	} else {
		return false
	}
}

func FromTestConnection(conn *sql.DB, kind string) *database {
	return &database{
		Interface: conn,
	}
}

func New(driver string, connectionString string, dbName string, options ConnectionOptions) (*database, error) {
	db, err := sql.Open(driver, connectionString)
	if err != nil {
		return nil, err
	}
	if err := db.Ping(); err != nil {
		return nil, err
	}

	db.SetConnMaxLifetime(options.OpenConnectionTimeout)
	db.SetConnMaxIdleTime(options.IdleConnectionTimeout)
	db.SetMaxIdleConns(options.MaxIdleConnections)
	db.SetMaxOpenConns(options.MaxOpenConnections)

	hist := promauto.NewHistogramVec(prometheus.HistogramOpts{
		Namespace: options.PromNS,
		Name:      fmt.Sprintf("%s_db_query_duration_seconds", dbName),
		Help:      "Database query durations by [dbName] [query]",
		Buckets: []float64{
			0.0005,
			0.001, // 1ms
			0.002,
			0.005,
			0.01, // 10ms
			0.02,
			0.05,
			0.1, // 100 ms
			0.2,
			0.5,
			1.0, // 1s
			2.0,
			5.0,
			10.0, // 10s
			15.0,
			20.0,
			30.0,
		},
	}, []string{"dbName", "goCall", "type", "table"})

	return &database{
		Interface: db,
		DbName:    dbName,
		metrics: &metrics{
			QueryHV: hist,
		},
	}, nil
}

func extractQueryInfo(query string) (queryType, tableName string) {
	// Normalize the query by removing extra spaces and converting to uppercase.
	query = strings.TrimSpace(strings.ToUpper(query))

	// Define regex patterns for different query types.
	selectPattern := `^\s*SELECT\s+.*\s+FROM\s+(\w+)\s*.*$`
	insertPattern := `^\s*INSERT\s+INTO\s+(\w+)\s*.*$`
	updatePattern := `^\s*UPDATE\s+(\w+)\s*SET\s+.*$`
	deletePattern := `^\s*DELETE\s+FROM\s+(\w+)\s*.*$`

	// Compile regex patterns.
	selectRegex, _ := regexp.Compile(selectPattern)
	insertRegex, _ := regexp.Compile(insertPattern)
	updateRegex, _ := regexp.Compile(updatePattern)
	deleteRegex, _ := regexp.Compile(deletePattern)

	// Check the query type and extract the table name.
	switch {
	case selectRegex.MatchString(query):
		queryType = "SELECT"
		matches := selectRegex.FindStringSubmatch(query)
		tableName = matches[1]
	case insertRegex.MatchString(query):
		queryType = "INSERT"
		matches := insertRegex.FindStringSubmatch(query)
		tableName = matches[1]
	case updateRegex.MatchString(query):
		queryType = "UPDATE"
		matches := updateRegex.FindStringSubmatch(query)
		tableName = matches[1]
	case deleteRegex.MatchString(query):
		queryType = "DELETE"
		matches := deleteRegex.FindStringSubmatch(query)
		tableName = matches[1]
	}

	if queryType == "" {
		queryType = "unknown"
	}
	if tableName == "" {
		tableName = "unknown"
	}

	return queryType, tableName
}

func Debug(i Interface) Interface {
	return &database{
		Interface: i,
		debug:     true,
	}
}

func callerInfo() []string {
	var pc uintptr
	var ok bool
	var file string
	var line int
	var name string

	callers := []string{}
	for i := 0; ; i++ {
		pc, file, line, ok = runtime.Caller(i)
		if !ok {
			// The breaks below failed to terminate the loop, and we ran off the
			// end of the call stack.
			break
		}

		// This is a huge edge case, but it will panic if this is the case, see #180
		if file == "<autogenerated>" {
			break
		}

		f := runtime.FuncForPC(pc)
		if f == nil {
			break
		}
		name = f.Name()

		// testing.tRunner is the standard library function that calls
		// tests. Subtests are called directly by tRunner, without going through
		// the Test/Benchmark/Example function that contains the t.Run calls, so
		// with subtests we should break when we hit tRunner, without adding it
		// to the list of callers.
		if name == "testing.tRunner" {
			break
		}

		parts := strings.Split(file, "/")
		if len(parts) > 1 {
			filename := parts[len(parts)-1]
			rest := strings.Join(parts[:len(parts)-1], "/")
			if (!strings.Contains(rest, "pkg/sequel")) && filename != "sql.go" {
				callers = append(callers, fmt.Sprintf("%s:%d", file, line))
			}
		}

		// // Drop the package
		// segments := strings.Split(name, ".")
		// name = segments[len(segments)-1]
		// if isTest(name, "Test") ||
		// 	isTest(name, "Benchmark") ||
		// 	isTest(name, "Example") {
		// 	break
		// }
	}

	return callers
}

func debugLog(query string) {
	stack := callerInfo()
	caller := "No Caller Found"
	if len(stack) > 0 {
		caller = stack[len(stack)-1]
	}
	if strings.Contains(caller, "_test.go") && len(stack) > 2 && !strings.Contains(stack[len(stack)-2], "pkg/sequel") {
		caller = stack[len(stack)-2]
	}
	fmt.Printf("%s => %s\n\n", caller, query)
}

func (db *database) Exec(query string, args ...any) (sql.Result, error) {

	return db.ExecContext(context.Background(), query, args...)
}

func (db *database) Query(query string, args ...any) (*sql.Rows, error) {

	return db.QueryContext(context.Background(), query, args...)
}

func (db *database) IsDebug() bool {
	return db.debug || testing.Verbose()
}

func (db *database) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	if isDebug(db) {
		debugLog(query)
		// dump.This(args)
	}
	if db.metrics == nil {
		return db.Interface.ExecContext(ctx, query, args...)
	}
	queryType, table := extractQueryInfo(query)
	timer := prometheus.NewTimer(db.metrics.QueryHV.WithLabelValues(db.DbName, "ExecContext", queryType, table))
	res, err := db.Interface.ExecContext(ctx, query, args...)
	timer.ObserveDuration()

	return res, err
}
func ToMap(rows *sql.Rows, err error) ([]map[string]interface{}, error) {
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	columnNames, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	// Result set
	var result []map[string]interface{}

	for rows.Next() {
		columns := make([]interface{}, len(columnNames))
		columnPointers := make([]interface{}, len(columnNames))
		for i, _ := range columns {
			columnPointers[i] = &columns[i]
		}

		if err := rows.Scan(columnPointers...); err != nil {
			return nil, err
		}

		m := make(map[string]interface{})
		for i, colName := range columnNames {
			val := columnPointers[i].(*interface{})
			m[colName] = *val
		}
		result = append(result, m)
	}

	return result, nil
}

func (db *database) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	if isDebug(db) {
		debugLog(query)
		// dump.This(args)
	}
	if db.metrics == nil {
		return db.Interface.QueryContext(ctx, query, args...)
	}
	queryType, table := extractQueryInfo(query)
	timer := prometheus.NewTimer(db.metrics.QueryHV.WithLabelValues(db.DbName, "QueryContext", queryType, table))
	rows, err := db.Interface.QueryContext(ctx, query, args...)
	timer.ObserveDuration()

	return rows, err
}

type Schema struct {
	pk            *int64
	pkName        string
	createdAtName string
	updatedAtName string
	columnOptions map[string]int
	fillable      []string
	table         string
	valueMap      map[string]any
	beforeWrite   []func(m Model) error
	afterRead     []func(m Model) error
}

const (
	_ = 1 << iota
	PK
	NoColumn
	CreatedAt
	UpdatedAt
	//TODO: can we specify json stuff in here, so it adds a callback to our beforewrite hooks.
)

func NewSchema(table string, columns ...any) *Schema {
	if len(columns) < 2 {
		panic("you didn't pass any columns in NewSchema call")
	}
	s := &Schema{
		columnOptions: map[string]int{},
		fillable:      []string{},
		table:         table,
		valueMap:      map[string]any{},
	}
	return s.columns(columns...)
}

type ColumnSpec struct {
	Name string
	Type reflect.Type
	IsPK bool
}

func (s *Schema) GetColumns() (string, []ColumnSpec) {
	var specs []ColumnSpec
	for _, fil := range s.fillable {
		var isPK bool
		if s.columnOptions[fil]&PK == PK {
			isPK = true
		}
		specs = append(specs, ColumnSpec{
			Name: fil,
			Type: reflect.TypeOf(s.valueMap[fil]).Elem(),
			IsPK: isPK,
		})
	}

	return s.table, specs
}

func (s *Schema) columns(kvs ...any) *Schema {
	var i int
	for i < len(kvs) {
		if _, isString := kvs[i].(string); isString {
			columnName := kvs[i].(string)
			if len(kvs) <= i+1 {
				panic("Columns should be in form of <column name> <pointer> <options which can be omitted>")
			}
			pointer := kvs[i+1]
			s.valueMap[columnName] = pointer

			if len(kvs) <= i+2 {
				s.fillable = append(s.fillable, columnName)
				break
			}
			if _, isInt := kvs[i+2].(int); isInt { // if it has some options
				option := kvs[i+2].(int)
				s.columnOptions[columnName] = option
				if option&PK == PK {
					s.pk = pointer.(*int64)
				}

				if option&PK == PK {
					s.pkName = columnName
				}

				if option&CreatedAt == CreatedAt {
					s.createdAtName = columnName
				}
				if option&UpdatedAt == UpdatedAt {
					s.updatedAtName = columnName
				}

				if (option&PK != PK) && (option&NoColumn != NoColumn) {
					s.fillable = append(s.fillable, columnName)
				}
				i += 3
			} else {
				s.fillable = append(s.fillable, columnName)
				i += 2
			}
			continue
		}
	}

	if s.createdAtName == "" {
		if s.valueMap["created_at"] != nil {
			s.createdAtName = "created_at"
		}
	}

	if s.updatedAtName == "" {
		if s.valueMap["updated_at"] != nil {
			s.updatedAtName = "updated_at"
		}
	}
	if s.pk == nil {
		if s.valueMap["id"] != nil {
			if _, isIntPtr := s.valueMap["id"].(*int64); isIntPtr {
				s.pk = s.valueMap["id"].(*int64)
			}
		}
		idIndex := 0
		for i, fil := range s.fillable {
			if fil == "id" {
				idIndex = i
			}
		}
		s.pkName = "id"

		s.fillable = append(s.fillable[:idIndex], s.fillable[idIndex+1:]...)

	}

	return s
}

func (s *Schema) BeforeWrite(fs ...func(m Model) error) *Schema {
	s.beforeWrite = append(s.beforeWrite, fs...)
	return s
}

func (s *Schema) AfterRead(fs ...func(m Model) error) *Schema {
	s.afterRead = append(s.afterRead, fs...)

	return s
}

func (s *Schema) Validate() error {
	if s.table == "" {
		return errors.Newf("No table has been defined")
	}
	if len(s.fillable) < 1 {
		return errors.Newf("No fillables defined for model of table %s", s.table)
	}
	if s.pk == nil {
		return errors.Newf("No primary key pointer was set for model of table %s", s.table)
	}

	if len(s.valueMap) == 0 {
		return errors.Newf("no field mapping defined for model of table %s", s.table)
	}
	//TODO(amirreza): optional reflection check for validity of types.

	return nil
}

type Model interface {
	Schema() *Schema
}

func Insert(db Interface, obj Model) (sql.Result, error) {
	schema := obj.Schema()
	if err := schema.Validate(); err != nil {
		return nil, errors.Wrap(err, "invalid schema")
	}
	for _, bi := range schema.beforeWrite {
		err := bi(obj)
		if err != nil {
			return nil, errors.Wrap(err, "error in running before insert hook %T", obj)
		}
	}
	schema = obj.Schema()
	table := schema.table
	columns := schema.fillable
	values := []any{}
	for _, col := range columns {
		values = append(values, schema.valueMap[col])
	}
	placeholders := strings.Repeat("?,", len(columns))
	placeholders = placeholders[:len(placeholders)-1]
	query := fmt.Sprintf(`INSERT INTO %s (%s) VALUES (%s)`,
		table,
		strings.Join(columns, ","),
		placeholders,
	)
	if isDebug(db) {
		debugLog(query)
		// dump.This(obj)
	}
	return db.Exec(
		query,
		values...,
	)
}

// TODO: make this to accept an array for bulk save.
func Save[T Model](db Interface, objs ...T) error {
	if len(objs) < 1 {
		return errors.New("you need to pass at least one model to save.")
	}
	schema := objs[0].Schema()
	if err := schema.Validate(); err != nil {
		return errors.Wrap(err, "invalid schema")
	}
	// if schema.pk == nil || *schema.pk == 0 {
	// 	_, err := Insert(db, objs[0]) //TODO
	// 	return err
	// }
	for _, obj := range objs {
		for _, bi := range schema.beforeWrite {
			err := bi(obj)
			if err != nil {
				return errors.Wrap(err, "error in running before insert hook %T", obj)
			}
		}
	}

	schema = objs[0].Schema()
	table := schema.table
	columns := schema.fillable
	values := []any{}
	updatePairs := []string{}
	for _, col := range columns {
		if getDriver(db) == "mysql" {
			updatePairs = append(updatePairs, fmt.Sprintf("%s=VALUES(%s)", col, col))
		} else if getDriver(db) == "postgres" || getDriver(db) == sqlite {
			updatePairs = append(updatePairs, fmt.Sprintf("%s=excluded.%s", col, col))
		} else {
			return fmt.Errorf("unsupported database '%s' for generating save query", getDriver(db))
		}
	}

	var valuePlaceholders []string
	for _, obj := range objs {
		thisSchema := obj.Schema()
		for _, col := range schema.fillable {
			values = append(values, thisSchema.valueMap[col])
		}
		placeholders := strings.Repeat("?,", len(schema.fillable))
		placeholders = placeholders[:len(placeholders)-1]
		valuePlaceholders = append(valuePlaceholders, fmt.Sprintf("(%s)", placeholders))
	}
	if getDriver(db) == sqlite || getDriver(db) == "postgres" {
		values = append(values, schema.pk)
	}
	var res sql.Result
	var err error
	if getDriver(db) == "mysql" {
		query := fmt.Sprintf(`INSERT INTO %s (%s) VALUES %s ON DUPLICATE KEY UPDATE %s`,
			table,
			strings.Join(columns, ","),
			strings.Join(valuePlaceholders, ","),
			strings.Join(updatePairs, ","),
		)
		if isDebug(db) {
			debugLog(query)
			for _, obj := range objs {
				dump.This(obj)
			}
		}
		res, err = db.Exec(
			query,
			values...,
		)
	} else if getDriver(db) == "postgres" || getDriver(db) == sqlite {
		query := fmt.Sprintf(`INSERT INTO %s (%s) VALUES %s ON CONFLICT (id) DO UPDATE SET %s WHERE ID=?`,
			table,
			strings.Join(columns, ","),
			strings.Join(valuePlaceholders, ","),
			strings.Join(updatePairs, ","),
		)
		if isDebug(db) {
			debugLog(query)
			// for _, obj := range objs {
			// 	dump.This(obj)
			// }
		}
		res, err = db.Exec(
			query,
			values...,
		)
	} else {
		return fmt.Errorf("unsupported database '%s' for generating save query", getDriver(db))
	}

	if err != nil {
		return errors.Wrap(err, "cannot save on table %s", table)
	}

	id, err := res.LastInsertId()
	if err == nil {
		if schema.pk != nil {
			*schema.pk = id
		}
	}

	return nil
}

func Delete(db *database, m Model) (sql.Result, error) {
	schema := m.Schema()
	pkName := schema.pkName
	pkValue := schema.valueMap[pkName]
	return db.Exec(fmt.Sprintf("DELETE FROM %s WHERE %s=?", schema.table, pkName), pkValue)
}

type pointer[T any] interface {
	Schema() *Schema
	*T
}

// func Query[M any, T Queryable[M]]() {
// 	var m M
// 	s := &m
// 	fmt.Printf("%T\n", m)
// 	fmt.Printf("%T\n", s)
// }

func Query[M any, T pointer[M]](db *database, q string, args ...any) ([]T, error) {
	if isDebug(db) {
		fmt.Printf("[Sql-DBG] %s\n", q)
		// dump.This(args)
	}
	rows, err := db.Query(q, args...)
	if err != nil {
		return nil, err
	}
	columns, err := rows.Columns()

	records := []T{}

	for rows.Next() {
		var m M
		s := T(&m)
		values := []any{}
		for _, col := range columns {
			values = append(values, s.Schema().valueMap[col])
		}
		rows.Scan(values...)
		thisSchema := s.Schema()
		for _, ar := range thisSchema.afterRead {
			err := ar(s)
			if err != nil {
				return nil, errors.Wrap(err, "error in processing after read for model of table %s", thisSchema.table)
			}
		}
		records = append(records, s)
	}

	return records, nil
}
